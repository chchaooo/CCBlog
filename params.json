{
  "name": "CCblog",
  "tagline": "博客集",
  "body": "\r\n## 0）拍照参数设置\r\n\r\n---\r\n\r\n### 照片格式\r\n\r\n#### 拍照格式\r\n\r\n#### 预览格式\r\n\r\n* 所有Android设备的相机均支持以下两种格式（要求by google）\r\n    * NV21\r\n    * YV12\r\n    \r\n    相机默认格式为NV21\r\n* 上述两种格式均定义在android.graphics.ImageFormat中。\r\n* YUV：\r\n    * 名词解释\r\n        * Y：luminance 亮度\r\n        * U：色彩\r\n        * V：饱和度\r\n    * 与所熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统。它将亮度信息（Y）与色彩信息（UV）分离，没有UV一样可以显示完整图像，只不过黑白的。这样的设计很好解决了彩色电视机与黑白电视机的兼容问题\r\n* NV21和YV12的区别\r\n    * YV12：将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。\r\n    * NV21：即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。\r\n\r\n\r\n---\r\n\r\n### 对焦\r\n\r\n* 绝大多数相机支持连续自动对焦\r\n* 可以设置具体的对焦点位于预览区域的哪个位置\r\n* 无法设置实际的焦距距离\r\n\r\nAPI中拍照模式定义：\r\n* **FOCUS_MODE_CONTINUOUS_PICTURE** ：Continuous auto focus mode intended for taking pictures.\r\n* **FOCUS_MODE_CONTINUOUS_VIDEO** ：Continuous auto focus mode intended for video recording.\r\n    \r\n\r\n    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);\r\n    if (parameters.getSupportedFocusModes().contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {\r\n        parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);\r\n    }\r\n\r\n### 拍照质量参数\r\n\r\n    /* 设置照片质量 */\r\n    Camera.Parameters parameters = mCurCamera.getParameters();\r\n    parameters.setJpegQuality(60);\r\n\r\n* 实际测试该动作需要的时间约为300ms\r\n* 拍照质量参数\r\n    * **参数与照片质量和最终的照片大小之间并不呈现线性相关关系，而是超过了某个门槛值之后，发送突变**\r\n    * 对小米note拍照清晰临界点在38左右\r\n        * 拍照质量参数设置为40左右照片大小约为730kb，仍基本保留了原本照片信息\r\n            ![](https://cl.ly/1O1e061x0r2A/40-730kb.jpg)\r\n        * 设置为35时照片大小减小的并不多（640kb），但照片严重模糊，已经不可用。\r\n            ![](https://cl.ly/1K0A3r3I2o3R/30-550kb.jpg)\r\n    * 参数设置为40和70本身对照片大小的影响不是太大（700kb，1000kb），考虑不同设备存在不同情况应该设置稍高一点（60）\r\n    * 参数设置为70和100，照片质量差距肉眼难以分辨，但照片大小差距巨大（1000kb， 4000kb）\r\n    * 拍照参数未设置时，拍照质量的默认值根据照片大小900kb和清晰度推测为60左右\r\n\r\n   \r\n\r\n* **上述拍照质量的设置与压缩照片的质量是否存在关联性质？**\r\n* **该设置只是对生成的照片生效，获取到的预览帧是与参数无关的？？？**\r\n\r\n\r\n---\r\n\r\n## 2）获取图片\r\n\r\n---\r\n\r\n#### FUNC 0 : AutoFocusCallback\r\n\r\n    mCamera.autoFocus(AutoFocusCallback cb){\r\n        ..\r\n    }\r\n\r\n* 只有对焦成功之后回调才会触发（若未成功则不会拍摄照片）\r\n\r\n#### FUNC 1 : PictureCallback\r\n\r\n    /* from android.hardware */\r\n    Camera.ShutterCallback shutter = new Camera.ShutterCallback() {\r\n        @Override\r\n        public void onShutter() {\r\n            /** Default Action: Camera Sound*/\r\n        }\r\n    };\r\n    \r\n    PictureCallback picListener = new PictureCallback() {\r\n        @Override\r\n        public void onPictureTaken(final byte[] data, Camera camera1) {\r\n            ...\r\n        }\r\n    }\r\n    \r\n    /* ShutterCallback shutter, PictureCallback raw,PictureCallback jpeg */\r\n    public final void takePicture(shutter, picListener, null) {\r\n        ...    \r\n    }\r\n\r\n\r\n#### FUNC2 :  PreviewCallback\r\n\r\n##### 1）setPreviewCallback\r\n    \r\n    PreviewCallback previewCB = new Camera.PreviewCallback() {\r\n        @Override\r\n        public void onPreviewFrame(byte[] data, Camera camera) {\r\n            ...\r\n        }\r\n    }\r\n    mCamera.setPreviewCallback(previewCB);\r\n\r\n* 正常情况下一秒钟回传约30帧\r\n* 当连续拍照，手机发热比较严重时，帧率会下降。\r\n\r\n##### 2）setPreviewCallbackWithBuffer\r\n\r\n* 使用setPreviewCallback来处理帧时，每一针都需要新开辟一个新的buffer来存储帧数据。不断开辟和回收内存，频繁导致GC。\r\n\r\n    \r\n    mCamera.setPreviewCallbackWithBuffer(new Camera.PreviewCallback(){\r\n        @Override\r\n        public void onPreviewFrame(byte[] data, Camera camera){\r\n            ...\r\n        }\r\n    }\r\n    mCamera.addCallbackBuffer(\r\n    new byte[((previewWidth * previewHeight) *ImageFormat.getBitsPerPixel(ImageFormat.NV21)) / 8]);\r\n\r\n> 当设置setPreviewCallbackWithBuffer(null)之后，之前设置的buffer也被删除；当重新设置回调之后，也需要重新添加buffer。当未设置buffer时，该回调将不会起作用。\r\n\r\n\r\n---\r\n\r\n## 3）压缩\r\n\r\n#### 按分辨率压缩/裁剪\r\n\r\n    private Bitmap compressPicTo1080(Bitmap picture) throws Exception, Error{\r\n        /* 保证长宽关系，如果宽大于高度，旋转照片 */\r\n        Bitmap picture;\r\n        if (picture.getHeight() < picture.getWidth()) {\r\n            Matrix matrix = new Matrix();\r\n            matrix.postRotate(90.0f);\r\n            picture = Bitmap.createBitmap(picture, 0, 0, picture.getWidth(), picture.getHeight(), matrix, true);\r\n        }else {\r\n            picture = picture;\r\n        }\r\n        if(picture.getHeight() == 1920 && picture.getWidth() == 1080){\r\n            return picture;\r\n        }\r\n        \r\n        /* 调整长宽比例，裁剪照片 */\r\n        int orignHeight = picture.getHeight();\r\n        int orignWidth = picture.getWidth();\r\n        int desWidth = orignHeight * 1080 / 1920;\r\n        int startX = (orignWidth - desWidth) / 2;\r\n        int startY = 0;\r\n        Bitmap picture = Bitmap.createBitmap(picture, startX, startY, desWidth, orignHeight);\r\n        \r\n        /* 保持原比例压缩照片分辨率 */\r\n        float scaleWidth = (float) 1080 / desWidth;\r\n        float scaleHeight = (float) 1920 / orignHeight;\r\n        Matrix matrix = new Matrix();\r\n        matrix.postScale(scaleWidth, scaleHeight);\r\n        Bitmap resizeBitmap = Bitmap.createBitmap(picture, 0, 0, desWidth, orignHeight, matrix, false);\r\n        return resizeBitmap;\r\n    }\r\n\r\n    \r\n    \r\n\r\n#### 按照片质量压缩\r\n\r\n    ByteArrayOutputStream array = new ByteArrayOutputStream();\r\n    array.reset();\r\n    /* 照片信息原本在bitmap中，压缩之后存在于array中 */\r\n    bitmap.compress(Bitmap.CompressFormat.JPEG, 65, array);\r\n    \r\n* **照片质量参数与拍照时设置的拍照质量参数是否效果相同？**\r\n    \r\n---\r\n\r\n#### 预览帧的压缩\r\n\r\n    /* 数据源头为photoTask.getImageData(),格式为byte[] */\r\n    Size size = mCameraManager.getCamera().getParameters().getPreviewSize();\r\n    final int previewWidth = size.width;\r\n    final int previewHeight = size.height;\r\n    final YuvImage image = new YuvImage(photoTask.getImageData(), ImageFormat.NV21, previewWidth, previewHeight, null);\r\n    ByteArrayOutputStream os = new ByteArrayOutputStream(photoTask.getImageData().length);\r\n    if (!image.compressToJpeg(new Rect(0, 0, previewWidth, previewHeight), 100, os)) {\r\n        return;\r\n    }\r\n    byte[] bytestmp = os.toByteArray();\r\n    Bitmap bmp = BitmapFactory.decodeByteArray(bytestmp, 0, bytestmp.length);\r\n\r\n    ByteArrayOutputStream array = new ByteArrayOutputStream();\r\n    array.reset();\r\n    if (bmp == null) {\r\n        return;\r\n    }\r\n    bmp.compress(Bitmap.CompressFormat.JPEG, 65, array);\r\n    Utils.writeToFile(file, array.toByteArray());\r\n\r\n\r\n\r\n\r\n---\r\n\r\n## 源码\r\n\r\n     /**\r\n         * Sets the image format for preview pictures.\r\n         * <p>If this is never called, the default format will be\r\n         * {@link android.graphics.ImageFormat#NV21}, which\r\n         * uses the NV21 encoding format.</p>\r\n         * \r\n         该方法用于设置预览的格式。默认预览格式为 android.graphics.ImageFormat#NV21\r\n         \r\n         * <p>Use {@link Parameters#getSupportedPreviewFormats} to get a list of\r\n         * the available preview formats.\r\n         可以使用Parameters.getSupportedPreviewFormats来获取支持的预览格式\r\n         \r\n         * <p>It is strongly recommended that either\r\n         * {@link android.graphics.ImageFormat#NV21} or\r\n         * {@link android.graphics.ImageFormat#YV12} is used, since\r\n         * they are supported by all camera devices.</p>\r\n         强烈推荐使用NV21或者是YV12格式，所有AndroidManifest相机设备均支持这两个预览格式\r\n         \r\n         * <p>For YV12, the image buffer that is received is not necessarily\r\n         * tightly packed, as there may be padding at the end of each row of\r\n         * pixel data, as described in\r\n         * {@link android.graphics.ImageFormat#YV12}. For camera callback data,\r\n         * it can be assumed that the stride of the Y and UV data is the\r\n         * smallest possible that meets the alignment requirements. That is, if\r\n         * the preview size is <var>width x height</var>, then the following\r\n         * equations describe the buffer index for the beginning of row\r\n         * <var>y</var> for the Y plane and row <var>c</var> for the U and V\r\n         * planes:\r\n         *\r\n         * {@code\r\n         * <pre>\r\n         * yStride   = (int) ceil(width / 16.0) * 16;\r\n         * uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;\r\n         * ySize     = yStride * height;\r\n         * uvSize    = uvStride * height / 2;\r\n         * yRowIndex = yStride * y;\r\n         * uRowIndex = ySize + uvSize + uvStride * c;\r\n         * vRowIndex = ySize + uvStride * c;\r\n         * size      = ySize + uvSize * 2;</pre>\r\n         * }\r\n         *\r\n         * @param pixel_format the desired preview picture format, defined by\r\n         *   one of the {@link android.graphics.ImageFormat} constants.  (E.g.,\r\n         *   <var>ImageFormat.NV21</var> (default), or\r\n         *   <var>ImageFormat.YV12</var>)\r\n         *\r\n         * @see android.graphics.ImageFormat\r\n         * @see android.hardware.Camera.Parameters#getSupportedPreviewFormats\r\n         */\r\n        public void setPreviewFormat(int pixel_format) {\r\n            ...\r\n        }\r\n        \r\n    \r\n\r\n\r\n\r\n\r\n---\r\n\r\n### 其他\r\n\r\n#### 获取本地图片\r\n\r\n    /**\r\n     * 读取图片\r\n     * @param reqWidth  所需图片压缩尺寸最小宽度\r\n     * @param reqHeight 所需图片压缩尺寸最小高度\r\n     */\r\n    public static Bitmap decodeSampledBitmapFromFile(String filepath,int reqWidth, int reqHeight) {\r\n    \r\n        /* 获取本地图片分辨率，而并不加载 */\r\n        final BitmapFactory.Options options = new BitmapFactory.Options();\r\n        options.inJustDecodeBounds = true;\r\n        BitmapFactory.decodeFile(filepath, options);\r\n        \r\n        /* 按照目标长宽来计算压缩比例 */\r\n        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\r\n        \r\n        /* 实际加载图片 */\r\n        options.inJustDecodeBounds = false;\r\n        return BitmapFactory.decodeFile(filepath, options);\r\n    }",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}